2023-08-27 22:12:36:826 grammar LogManager.java:25 before: (LEXER_GRAMMAR SwiftLexer (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE STR (BLOCK (ALT 'String'))) (RULE TRU (BLOCK (ALT 'true'))) (RULE FAL (BLOCK (ALT 'false'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE IN (BLOCK (ALT 'in'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE DIF (BLOCK (ALT '!='))) (RULE IG_IG (BLOCK (ALT '=='))) (RULE NOT (BLOCK (ALT '!'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE IG (BLOCK (ALT '='))) (RULE MAY_IG (BLOCK (ALT '>='))) (RULE MEN_IG (BLOCK (ALT '<='))) (RULE MAYOR (BLOCK (ALT '>'))) (RULE MENOR (BLOCK (ALT '<'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE ADD (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE PARIZQ (BLOCK (ALT '('))) (RULE PARDER (BLOCK (ALT ')'))) (RULE LLAVEIZQ (BLOCK (ALT '{'))) (RULE LLAVEDER (BLOCK (ALT '}'))) (RULE D_PTS (BLOCK (ALT ':'))) (RULE CORIZQ (BLOCK (ALT '['))) (RULE CORDER (BLOCK (ALT ']'))) (RULE COMA (BLOCK (ALT ','))) (RULE PUNTO (BLOCK (ALT '.'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \\\r\n\t])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))))
2023-08-27 22:12:36:851 grammar LogManager.java:25 after: (LEXER_GRAMMAR SwiftLexer (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE STR (BLOCK (ALT 'String'))) (RULE TRU (BLOCK (ALT 'true'))) (RULE FAL (BLOCK (ALT 'false'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE IN (BLOCK (ALT 'in'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE DIF (BLOCK (ALT '!='))) (RULE IG_IG (BLOCK (ALT '=='))) (RULE NOT (BLOCK (ALT '!'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE IG (BLOCK (ALT '='))) (RULE MAY_IG (BLOCK (ALT '>='))) (RULE MEN_IG (BLOCK (ALT '<='))) (RULE MAYOR (BLOCK (ALT '>'))) (RULE MENOR (BLOCK (ALT '<'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE ADD (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE PARIZQ (BLOCK (ALT '('))) (RULE PARDER (BLOCK (ALT ')'))) (RULE LLAVEIZQ (BLOCK (ALT '{'))) (RULE LLAVEDER (BLOCK (ALT '}'))) (RULE D_PTS (BLOCK (ALT ':'))) (RULE CORIZQ (BLOCK (ALT '['))) (RULE CORDER (BLOCK (ALT ']'))) (RULE COMA (BLOCK (ALT ','))) (RULE PUNTO (BLOCK (ALT '.'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \\\r\n\t])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
2023-08-27 22:12:37:423 grammar LogManager.java:25 before: (COMBINED_GRAMMAR SwiftGrammar (OPTIONS (= tokenVocab SwiftLexer)) (@ header {
    import "Server2/interfaces"
    import "Server2/environment"
    import "Server2/expressions"
    import "Server2/instructions"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {   
        $code = $block.blk
    }))) (RULE block (returns []interface{} blk) (@ init {
    $blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT ifstmt { $inst = $ifstmt.ifinst }) (ALT declarationstmt { $inst = $declarationstmt.dec }) (ALT asignacion { $inst = $asignacion.asign}) (ALT whilestmt { $inst = $whilestmt.whiles }) (ALT forstmt { $inst = $forstmt.fors }) (ALT switchtmt { $inst = $switchtmt.swtch }))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER { $prnt = instructions.NewPrint($PRINT.line,$PRINT.pos,$expr.e)}))) (RULE forstmt (returns interfaces.Instruction fors) (BLOCK (ALT FOR ID IN (= e1 expr) PUNTO PUNTO PUNTO (= e2 expr) LLAVEIZQ block LLAVEDER { $fors = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, $e1.e,$e2.e,"nil", $block.blk) }) (ALT FOR ID IN (= ope (BLOCK (ALT STRING) (ALT ID))) LLAVEIZQ block LLAVEDER { $fors = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, nil,nil, $ope.text ,$block.blk ) }))) (RULE switchtmt (returns interfaces.Instruction swtch) (BLOCK (ALT SWITCH (= exprsw expr) LLAVEIZQ caselist LLAVEDER { $swtch = instructions.NewSwitch( $SWITCH.line, $SWITCH.pos, $exprsw.e, nil, $caselist.cases, nil ) }))) (RULE caselist (returns []interface{} cases) (BLOCK (ALT (= listcases caselist) case { var arr3 []interface{}
                        arr3= append($listcases.cases, $case.swtch)
                        $cases= arr3
                        }) (ALT case {
                            $cases= []interface{}{}
                            $cases = append($cases, $case.swtch)
                        }))) (RULE case (returns interfaces.Instruction swtch) (BLOCK (ALT CASE expr D_PTS block { $swtch = instructions.NewSwitch( $CASE.line, $CASE.pos, $exprsw.e ,$expr.e, nil, $block.blk ) }))) (RULE ifstmt (returns interfaces.Instruction ifinst) (BLOCK (ALT IF expr LLAVEIZQ block LLAVEDER { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, nil, nil) }) (ALT IF expr LLAVEIZQ (= b1 block) LLAVEDER ELSE LLAVEIZQ (= b2 block) LLAVEDER {$ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $b1.blk, nil, $b2.blk) }) (ALT IF expr LLAVEIZQ block LLAVEDER elseiflist { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, $elseiflist.else_if_list, nil) }) (ALT IF expr LLAVEIZQ (= b1 block) LLAVEDER elseiflist ELSE LLAVEIZQ (= b2 block) LLAVEDER { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $b1.blk, $elseiflist.else_if_list, $b2.blk) }))) (RULE elseiflist (returns []interface{} else_if_list) (BLOCK (ALT (= listif elseiflist) elseif {   var arr2 []interface{}
                        arr2 = append($listif.else_if_list, $elseif.ifinst)
                        $else_if_list = arr2
                    }) (ALT elseif {
                $else_if_list = []interface{}{}
                $else_if_list = append($else_if_list, $elseif.ifinst)

            }))) (RULE elseif (returns interfaces.Instruction ifinst) (BLOCK (ALT ELSE IF expr LLAVEIZQ block LLAVEDER { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, nil, nil) }))) (RULE whilestmt (returns interfaces.Instruction whiles) (BLOCK (ALT WHILE expr LLAVEIZQ block LLAVEDER { $whiles =instructions.NewWhiles($WHILE.line, $WHILE.pos, $expr.e, $block.blk) }))) (RULE declarationstmt (returns interfaces.Instruction dec) (BLOCK (ALT VAR ID D_PTS types IG expr {
            $dec = instructions.NewDeclaration($VAR.line, $VAR.pos, $ID.text, $types.ty, $expr.e);
        }))) (RULE asignacion (returns interfaces.Instruction asign) (BLOCK (ALT ID IG expr { $asign = instructions.NewAsignacion($ID.line ,$ID.pos ,$ID.text, $expr.e) }))) (RULE types (returns environment.TipoExpresion ty) (BLOCK (ALT INT { $ty = environment.INTEGER }) (ALT FLOAT { $ty = environment.FLOAT }) (ALT STR { $ty = environment.STRING }) (ALT BOOL { $ty = environment.BOOLEAN }) (ALT CORIZQ CORDER { $ty = environment.ARRAY }))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (BLOCK (ALT MUL) (ALT DIV))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT ADD) (ALT SUB))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT MAY_IG) (ALT MAYOR))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT MEN_IG) (ALT MENOR))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT IG_IG) (ALT DIF))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT (= list listArray) { $e = $list.p}) (ALT CORIZQ listParams CORDER { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRU { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT FAL { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) }))) (RULE listParams (returns []interface{} l) (BLOCK (ALT (= list listParams) COMA expr {
                                var arr []interface{}
                                arr = append($list.l, $expr.e)
                                $l = arr
                            }) (ALT expr {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        }))) (RULE listArray (returns interfaces.Expression p) (BLOCK (ALT (= list listArray) CORIZQ expr CORDER { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }) (ALT ID { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)})))))
2023-08-27 22:12:37:438 grammar LogManager.java:25 after: (COMBINED_GRAMMAR SwiftGrammar (OPTIONS (= tokenVocab SwiftLexer)) (@ header {
    import "Server2/interfaces"
    import "Server2/environment"
    import "Server2/expressions"
    import "Server2/instructions"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {   
        $code = $block.blk
    }))) (RULE block (returns []interface{} blk) (@ init {
    $blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT ifstmt { $inst = $ifstmt.ifinst }) (ALT declarationstmt { $inst = $declarationstmt.dec }) (ALT asignacion { $inst = $asignacion.asign}) (ALT whilestmt { $inst = $whilestmt.whiles }) (ALT forstmt { $inst = $forstmt.fors }) (ALT switchtmt { $inst = $switchtmt.swtch }))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER { $prnt = instructions.NewPrint($PRINT.line,$PRINT.pos,$expr.e)}))) (RULE forstmt (returns interfaces.Instruction fors) (BLOCK (ALT FOR ID IN (= e1 expr) PUNTO PUNTO PUNTO (= e2 expr) LLAVEIZQ block LLAVEDER { $fors = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, $e1.e,$e2.e,"nil", $block.blk) }) (ALT FOR ID IN (= ope (SET STRING ID)) LLAVEIZQ block LLAVEDER { $fors = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, nil,nil, $ope.text ,$block.blk ) }))) (RULE switchtmt (returns interfaces.Instruction swtch) (BLOCK (ALT SWITCH (= exprsw expr) LLAVEIZQ caselist LLAVEDER { $swtch = instructions.NewSwitch( $SWITCH.line, $SWITCH.pos, $exprsw.e, nil, $caselist.cases, nil ) }))) (RULE caselist (returns []interface{} cases) (BLOCK (ALT (= listcases caselist) case { var arr3 []interface{}
                        arr3= append($listcases.cases, $case.swtch)
                        $cases= arr3
                        }) (ALT case {
                            $cases= []interface{}{}
                            $cases = append($cases, $case.swtch)
                        }))) (RULE case (returns interfaces.Instruction swtch) (BLOCK (ALT CASE expr D_PTS block { $swtch = instructions.NewSwitch( $CASE.line, $CASE.pos, $exprsw.e ,$expr.e, nil, $block.blk ) }))) (RULE ifstmt (returns interfaces.Instruction ifinst) (BLOCK (ALT IF expr LLAVEIZQ block LLAVEDER { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, nil, nil) }) (ALT IF expr LLAVEIZQ (= b1 block) LLAVEDER ELSE LLAVEIZQ (= b2 block) LLAVEDER {$ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $b1.blk, nil, $b2.blk) }) (ALT IF expr LLAVEIZQ block LLAVEDER elseiflist { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, $elseiflist.else_if_list, nil) }) (ALT IF expr LLAVEIZQ (= b1 block) LLAVEDER elseiflist ELSE LLAVEIZQ (= b2 block) LLAVEDER { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $b1.blk, $elseiflist.else_if_list, $b2.blk) }))) (RULE elseiflist (returns []interface{} else_if_list) (BLOCK (ALT (= listif elseiflist) elseif {   var arr2 []interface{}
                        arr2 = append($listif.else_if_list, $elseif.ifinst)
                        $else_if_list = arr2
                    }) (ALT elseif {
                $else_if_list = []interface{}{}
                $else_if_list = append($else_if_list, $elseif.ifinst)

            }))) (RULE elseif (returns interfaces.Instruction ifinst) (BLOCK (ALT ELSE IF expr LLAVEIZQ block LLAVEDER { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, nil, nil) }))) (RULE whilestmt (returns interfaces.Instruction whiles) (BLOCK (ALT WHILE expr LLAVEIZQ block LLAVEDER { $whiles =instructions.NewWhiles($WHILE.line, $WHILE.pos, $expr.e, $block.blk) }))) (RULE declarationstmt (returns interfaces.Instruction dec) (BLOCK (ALT VAR ID D_PTS types IG expr {
            $dec = instructions.NewDeclaration($VAR.line, $VAR.pos, $ID.text, $types.ty, $expr.e);
        }))) (RULE asignacion (returns interfaces.Instruction asign) (BLOCK (ALT ID IG expr { $asign = instructions.NewAsignacion($ID.line ,$ID.pos ,$ID.text, $expr.e) }))) (RULE types (returns environment.TipoExpresion ty) (BLOCK (ALT INT { $ty = environment.INTEGER }) (ALT FLOAT { $ty = environment.FLOAT }) (ALT STR { $ty = environment.STRING }) (ALT BOOL { $ty = environment.BOOLEAN }) (ALT CORIZQ CORDER { $ty = environment.ARRAY }))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (SET MUL DIV)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET ADD SUB)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MAY_IG MAYOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MEN_IG MENOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET IG_IG DIF)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT (= list listArray) { $e = $list.p}) (ALT CORIZQ listParams CORDER { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRU { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT FAL { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) }))) (RULE listParams (returns []interface{} l) (BLOCK (ALT (= list listParams) COMA expr {
                                var arr []interface{}
                                arr = append($list.l, $expr.e)
                                $l = arr
                            }) (ALT expr {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        }))) (RULE listArray (returns interfaces.Expression p) (BLOCK (ALT (= list listArray) CORIZQ expr CORDER { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }) (ALT ID { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)})))))
2023-08-27 22:12:37:443 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR SwiftGrammar (OPTIONS (= tokenVocab SwiftLexer)) (@ header {
    import "Server2/interfaces"
    import "Server2/environment"
    import "Server2/expressions"
    import "Server2/instructions"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {   
        $code = $block.blk
    }))) (RULE block (returns []interface{} blk) (@ init {
    $blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT ifstmt { $inst = $ifstmt.ifinst }) (ALT declarationstmt { $inst = $declarationstmt.dec }) (ALT asignacion { $inst = $asignacion.asign}) (ALT whilestmt { $inst = $whilestmt.whiles }) (ALT forstmt { $inst = $forstmt.fors }) (ALT switchtmt { $inst = $switchtmt.swtch }))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER { $prnt = instructions.NewPrint($PRINT.line,$PRINT.pos,$expr.e)}))) (RULE forstmt (returns interfaces.Instruction fors) (BLOCK (ALT FOR ID IN (= e1 expr) PUNTO PUNTO PUNTO (= e2 expr) LLAVEIZQ block LLAVEDER { $fors = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, $e1.e,$e2.e,"nil", $block.blk) }) (ALT FOR ID IN (= ope (SET STRING ID)) LLAVEIZQ block LLAVEDER { $fors = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, nil,nil, $ope.text ,$block.blk ) }))) (RULE switchtmt (returns interfaces.Instruction swtch) (BLOCK (ALT SWITCH (= exprsw expr) LLAVEIZQ caselist LLAVEDER { $swtch = instructions.NewSwitch( $SWITCH.line, $SWITCH.pos, $exprsw.e, nil, $caselist.cases, nil ) }))) (RULE caselist (returns []interface{} cases) (BLOCK (ALT (= listcases caselist) case { var arr3 []interface{}
                        arr3= append($listcases.cases, $case.swtch)
                        $cases= arr3
                        }) (ALT case {
                            $cases= []interface{}{}
                            $cases = append($cases, $case.swtch)
                        }))) (RULE case (returns interfaces.Instruction swtch) (BLOCK (ALT CASE expr D_PTS block { $swtch = instructions.NewSwitch( $CASE.line, $CASE.pos, $exprsw.e ,$expr.e, nil, $block.blk ) }))) (RULE ifstmt (returns interfaces.Instruction ifinst) (BLOCK (ALT IF expr LLAVEIZQ block LLAVEDER { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, nil, nil) }) (ALT IF expr LLAVEIZQ (= b1 block) LLAVEDER ELSE LLAVEIZQ (= b2 block) LLAVEDER {$ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $b1.blk, nil, $b2.blk) }) (ALT IF expr LLAVEIZQ block LLAVEDER elseiflist { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, $elseiflist.else_if_list, nil) }) (ALT IF expr LLAVEIZQ (= b1 block) LLAVEDER elseiflist ELSE LLAVEIZQ (= b2 block) LLAVEDER { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $b1.blk, $elseiflist.else_if_list, $b2.blk) }))) (RULE elseiflist (returns []interface{} else_if_list) (BLOCK (ALT (= listif elseiflist) elseif {   var arr2 []interface{}
                        arr2 = append($listif.else_if_list, $elseif.ifinst)
                        $else_if_list = arr2
                    }) (ALT elseif {
                $else_if_list = []interface{}{}
                $else_if_list = append($else_if_list, $elseif.ifinst)

            }))) (RULE elseif (returns interfaces.Instruction ifinst) (BLOCK (ALT ELSE IF expr LLAVEIZQ block LLAVEDER { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, nil, nil) }))) (RULE whilestmt (returns interfaces.Instruction whiles) (BLOCK (ALT WHILE expr LLAVEIZQ block LLAVEDER { $whiles =instructions.NewWhiles($WHILE.line, $WHILE.pos, $expr.e, $block.blk) }))) (RULE declarationstmt (returns interfaces.Instruction dec) (BLOCK (ALT VAR ID D_PTS types IG expr {
            $dec = instructions.NewDeclaration($VAR.line, $VAR.pos, $ID.text, $types.ty, $expr.e);
        }))) (RULE asignacion (returns interfaces.Instruction asign) (BLOCK (ALT ID IG expr { $asign = instructions.NewAsignacion($ID.line ,$ID.pos ,$ID.text, $expr.e) }))) (RULE types (returns environment.TipoExpresion ty) (BLOCK (ALT INT { $ty = environment.INTEGER }) (ALT FLOAT { $ty = environment.FLOAT }) (ALT STR { $ty = environment.STRING }) (ALT BOOL { $ty = environment.BOOLEAN }) (ALT CORIZQ CORDER { $ty = environment.ARRAY }))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (SET MUL DIV)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET ADD SUB)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MAY_IG MAYOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MEN_IG MENOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET IG_IG DIF)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT (= list listArray) { $e = $list.p}) (ALT CORIZQ listParams CORDER { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRU { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT FAL { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) }))) (RULE listParams (returns []interface{} l) (BLOCK (ALT (= list listParams) COMA expr {
                                var arr []interface{}
                                arr = append($list.l, $expr.e)
                                $l = arr
                            }) (ALT expr {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        }))) (RULE listArray (returns interfaces.Expression p) (BLOCK (ALT (= list listArray) CORIZQ expr CORDER { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }) (ALT ID { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)})))))
2023-08-27 22:12:37:443 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR SwiftGrammarLexer OPTIONS (@ header {
    import "Server2/interfaces"
    import "Server2/environment"
    import "Server2/expressions"
    import "Server2/instructions"
    import "strings"
}) RULES)
2023-08-27 22:12:37:478 left-recursion LogManager.java:25 caselist returns [[]interface{} cases]
    :   ( {} case<tokenIndex=239>                  {
                            $cases= []interface{}{}
                            $cases = append($cases, $case.swtch)
                        } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 2)}?<p=2> case<tokenIndex=233> { var arr3 []interface{}
                                  arr3= append($listcases.cases, $case.swtch)
                                  $cases= arr3
                                  }
        )*
    ;
2023-08-27 22:12:37:488 grammar LogManager.java:25 added: (RULE caselist (returns []interface{} cases) (BLOCK (ALT (BLOCK (ALT {} (case (ELEMENT_OPTIONS (= tokenIndex 239))) {
                            $cases= []interface{}{}
                            $cases = append($cases, $case.swtch)
                        })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 2)}? (ELEMENT_OPTIONS (= p 2))) (case (ELEMENT_OPTIONS (= tokenIndex 233))) { var arr3 []interface{}
                                  arr3= append($listcases.cases, $case.swtch)
                                  $cases= arr3
                                  }))))))
2023-08-27 22:12:37:488 left-recursion LogManager.java:25 elseiflist returns [[]interface{} else_if_list]
    :   ( {} elseif<tokenIndex=374>    {
                $else_if_list = []interface{}{}
                $else_if_list = append($else_if_list, $elseif.ifinst)

            } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 2)}?<p=2> elseif<tokenIndex=368> {   var arr2 []interface{}
                                  arr2 = append($listif.else_if_list, $elseif.ifinst)
                                  $else_if_list = arr2
                              }
        )*
    ;
2023-08-27 22:12:37:493 grammar LogManager.java:25 added: (RULE elseiflist (returns []interface{} else_if_list) (BLOCK (ALT (BLOCK (ALT {} (elseif (ELEMENT_OPTIONS (= tokenIndex 374))) {
                $else_if_list = []interface{}{}
                $else_if_list = append($else_if_list, $elseif.ifinst)

            })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 2)}? (ELEMENT_OPTIONS (= p 2))) (elseif (ELEMENT_OPTIONS (= tokenIndex 368))) {   var arr2 []interface{}
                                  arr2 = append($listif.else_if_list, $elseif.ifinst)
                                  $else_if_list = arr2
                              }))))))
2023-08-27 22:12:37:498 left-recursion LogManager.java:25 expr returns [interfaces.Expression e]
    :   ( {} PARIZQ<tokenIndex=647> expr<tokenIndex=649> PARDER<tokenIndex=651> { $e = $expr.e } 
        | list=listArray<tokenIndex=659> { $e = $list.p} 
        | CORIZQ<tokenIndex=665> listParams<tokenIndex=667> CORDER<tokenIndex=669> { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) } 
        | NUMBER<tokenIndex=675>                             
    {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    } 
        | STRING<tokenIndex=681>
    {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    } 
        | TRU<tokenIndex=687> { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) } 
        | FAL<tokenIndex=693> { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 14)}?<p=14> op=(MUL<tokenIndex=522>|DIV<tokenIndex=524>) right=expr<tokenIndex=529,p=15> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 13)}?<p=13> op=(ADD<tokenIndex=542>|SUB<tokenIndex=544>) right=expr<tokenIndex=549,p=14> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 12)}?<p=12> op=(MAY_IG<tokenIndex=562>|MAYOR<tokenIndex=564>) right=expr<tokenIndex=569,p=13> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 11)}?<p=11> op=(MEN_IG<tokenIndex=582>|MENOR<tokenIndex=584>) right=expr<tokenIndex=589,p=12> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 10)}?<p=10> op=(IG_IG<tokenIndex=602>|DIF<tokenIndex=604>) right=expr<tokenIndex=609,p=11> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 9)}?<p=9> op=AND<tokenIndex=621> right=expr<tokenIndex=625,p=10> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 8)}?<p=8> op=OR<tokenIndex=637> right=expr<tokenIndex=641,p=9> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
        )*
    ;
2023-08-27 22:12:37:513 grammar LogManager.java:25 added: (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (BLOCK (ALT {} (PARIZQ (ELEMENT_OPTIONS (= tokenIndex 647))) (expr (ELEMENT_OPTIONS (= tokenIndex 649))) (PARDER (ELEMENT_OPTIONS (= tokenIndex 651))) { $e = $expr.e }) (ALT (= list (listArray (ELEMENT_OPTIONS (= tokenIndex 659)))) { $e = $list.p}) (ALT (CORIZQ (ELEMENT_OPTIONS (= tokenIndex 665))) (listParams (ELEMENT_OPTIONS (= tokenIndex 667))) (CORDER (ELEMENT_OPTIONS (= tokenIndex 669))) { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) }) (ALT (NUMBER (ELEMENT_OPTIONS (= tokenIndex 675))) {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT (STRING (ELEMENT_OPTIONS (= tokenIndex 681))) {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT (TRU (ELEMENT_OPTIONS (= tokenIndex 687))) { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT (FAL (ELEMENT_OPTIONS (= tokenIndex 693))) { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 14)}? (ELEMENT_OPTIONS (= p 14))) (= op (SET (MUL (ELEMENT_OPTIONS (= tokenIndex 522))) (DIV (ELEMENT_OPTIONS (= tokenIndex 524))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 529) (= p 15)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 13)}? (ELEMENT_OPTIONS (= p 13))) (= op (SET (ADD (ELEMENT_OPTIONS (= tokenIndex 542))) (SUB (ELEMENT_OPTIONS (= tokenIndex 544))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 549) (= p 14)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 12)}? (ELEMENT_OPTIONS (= p 12))) (= op (SET (MAY_IG (ELEMENT_OPTIONS (= tokenIndex 562))) (MAYOR (ELEMENT_OPTIONS (= tokenIndex 564))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 569) (= p 13)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 11)}? (ELEMENT_OPTIONS (= p 11))) (= op (SET (MEN_IG (ELEMENT_OPTIONS (= tokenIndex 582))) (MENOR (ELEMENT_OPTIONS (= tokenIndex 584))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 589) (= p 12)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 10)}? (ELEMENT_OPTIONS (= p 10))) (= op (SET (IG_IG (ELEMENT_OPTIONS (= tokenIndex 602))) (DIF (ELEMENT_OPTIONS (= tokenIndex 604))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 609) (= p 11)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 9)}? (ELEMENT_OPTIONS (= p 9))) (= op (AND (ELEMENT_OPTIONS (= tokenIndex 621)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 625) (= p 10)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 8)}? (ELEMENT_OPTIONS (= p 8))) (= op (OR (ELEMENT_OPTIONS (= tokenIndex 637)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 641) (= p 9)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }))))))
2023-08-27 22:12:37:513 left-recursion LogManager.java:25 listParams returns [[]interface{} l]
    :   ( {} expr<tokenIndex=718> {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 2)}?<p=2> COMA<tokenIndex=710> expr<tokenIndex=712> {
                                          var arr []interface{}
                                          arr = append($list.l, $expr.e)
                                          $l = arr
                                      }
        )*
    ;
2023-08-27 22:12:37:513 grammar LogManager.java:25 added: (RULE listParams (returns []interface{} l) (BLOCK (ALT (BLOCK (ALT {} (expr (ELEMENT_OPTIONS (= tokenIndex 718))) {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 2)}? (ELEMENT_OPTIONS (= p 2))) (COMA (ELEMENT_OPTIONS (= tokenIndex 710))) (expr (ELEMENT_OPTIONS (= tokenIndex 712))) {
                                          var arr []interface{}
                                          arr = append($list.l, $expr.e)
                                          $l = arr
                                      }))))))
2023-08-27 22:12:37:513 left-recursion LogManager.java:25 listArray returns [interfaces.Expression p]
    :   ( {} ID<tokenIndex=747> { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)} 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 2)}?<p=2> CORIZQ<tokenIndex=737> expr<tokenIndex=739> CORDER<tokenIndex=741> { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }
        )*
    ;
2023-08-27 22:12:37:518 grammar LogManager.java:25 added: (RULE listArray (returns interfaces.Expression p) (BLOCK (ALT (BLOCK (ALT {} (ID (ELEMENT_OPTIONS (= tokenIndex 747))) { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)})) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 2)}? (ELEMENT_OPTIONS (= p 2))) (CORIZQ (ELEMENT_OPTIONS (= tokenIndex 737))) (expr (ELEMENT_OPTIONS (= tokenIndex 739))) (CORDER (ELEMENT_OPTIONS (= tokenIndex 741))) { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }))))))
2023-08-27 22:12:37:558 grammar LogManager.java:25 import INT=1
2023-08-27 22:12:37:558 grammar LogManager.java:25 import FLOAT=2
2023-08-27 22:12:37:558 grammar LogManager.java:25 import BOOL=3
2023-08-27 22:12:37:558 grammar LogManager.java:25 import STR=4
2023-08-27 22:12:37:563 grammar LogManager.java:25 import TRU=5
2023-08-27 22:12:37:563 grammar LogManager.java:25 import FAL=6
2023-08-27 22:12:37:563 grammar LogManager.java:25 import PRINT=7
2023-08-27 22:12:37:563 grammar LogManager.java:25 import IF=8
2023-08-27 22:12:37:563 grammar LogManager.java:25 import ELSE=9
2023-08-27 22:12:37:563 grammar LogManager.java:25 import WHILE=10
2023-08-27 22:12:37:563 grammar LogManager.java:25 import FOR=11
2023-08-27 22:12:37:563 grammar LogManager.java:25 import SWITCH=12
2023-08-27 22:12:37:563 grammar LogManager.java:25 import CASE=13
2023-08-27 22:12:37:563 grammar LogManager.java:25 import IN=14
2023-08-27 22:12:37:563 grammar LogManager.java:25 import VAR=15
2023-08-27 22:12:37:563 grammar LogManager.java:25 import NUMBER=16
2023-08-27 22:12:37:563 grammar LogManager.java:25 import STRING=17
2023-08-27 22:12:37:563 grammar LogManager.java:25 import ID=18
2023-08-27 22:12:37:563 grammar LogManager.java:25 import DIF=19
2023-08-27 22:12:37:563 grammar LogManager.java:25 import IG_IG=20
2023-08-27 22:12:37:563 grammar LogManager.java:25 import NOT=21
2023-08-27 22:12:37:568 grammar LogManager.java:25 import OR=22
2023-08-27 22:12:37:568 grammar LogManager.java:25 import AND=23
2023-08-27 22:12:37:568 grammar LogManager.java:25 import IG=24
2023-08-27 22:12:37:568 grammar LogManager.java:25 import MAY_IG=25
2023-08-27 22:12:37:568 grammar LogManager.java:25 import MEN_IG=26
2023-08-27 22:12:37:568 grammar LogManager.java:25 import MAYOR=27
2023-08-27 22:12:37:568 grammar LogManager.java:25 import MENOR=28
2023-08-27 22:12:37:568 grammar LogManager.java:25 import MUL=29
2023-08-27 22:12:37:568 grammar LogManager.java:25 import DIV=30
2023-08-27 22:12:37:568 grammar LogManager.java:25 import ADD=31
2023-08-27 22:12:37:568 grammar LogManager.java:25 import SUB=32
2023-08-27 22:12:37:568 grammar LogManager.java:25 import PARIZQ=33
2023-08-27 22:12:37:568 grammar LogManager.java:25 import PARDER=34
2023-08-27 22:12:37:568 grammar LogManager.java:25 import LLAVEIZQ=35
2023-08-27 22:12:37:568 grammar LogManager.java:25 import LLAVEDER=36
2023-08-27 22:12:37:568 grammar LogManager.java:25 import D_PTS=37
2023-08-27 22:12:37:568 grammar LogManager.java:25 import CORIZQ=38
2023-08-27 22:12:37:568 grammar LogManager.java:25 import CORDER=39
2023-08-27 22:12:37:568 grammar LogManager.java:25 import COMA=40
2023-08-27 22:12:37:568 grammar LogManager.java:25 import PUNTO=41
2023-08-27 22:12:37:568 grammar LogManager.java:25 import WHITESPACE=42
2023-08-27 22:12:37:573 grammar LogManager.java:25 import COMMENT=43
2023-08-27 22:12:37:573 grammar LogManager.java:25 import LINE_COMMENT=44
2023-08-27 22:12:37:573 grammar LogManager.java:25 import 'Int'=1
2023-08-27 22:12:37:573 grammar LogManager.java:25 import 'Float'=2
2023-08-27 22:12:37:573 grammar LogManager.java:25 import 'Bool'=3
2023-08-27 22:12:37:573 grammar LogManager.java:25 import 'String'=4
2023-08-27 22:12:37:573 grammar LogManager.java:25 import 'true'=5
2023-08-27 22:12:37:573 grammar LogManager.java:25 import 'false'=6
2023-08-27 22:12:37:573 grammar LogManager.java:25 import 'print'=7
2023-08-27 22:12:37:573 grammar LogManager.java:25 import 'if'=8
2023-08-27 22:12:37:573 grammar LogManager.java:25 import 'else'=9
2023-08-27 22:12:37:573 grammar LogManager.java:25 import 'while'=10
2023-08-27 22:12:37:573 grammar LogManager.java:25 import 'for'=11
2023-08-27 22:12:37:573 grammar LogManager.java:25 import 'switch'=12
2023-08-27 22:12:37:573 grammar LogManager.java:25 import 'case'=13
2023-08-27 22:12:37:573 grammar LogManager.java:25 import 'in'=14
2023-08-27 22:12:37:573 grammar LogManager.java:25 import 'var'=15
2023-08-27 22:12:37:573 grammar LogManager.java:25 import '!='=19
2023-08-27 22:12:37:573 grammar LogManager.java:25 import '=='=20
2023-08-27 22:12:37:573 grammar LogManager.java:25 import '!'=21
2023-08-27 22:12:37:573 grammar LogManager.java:25 import '||'=22
2023-08-27 22:12:37:573 grammar LogManager.java:25 import '&&'=23
2023-08-27 22:12:37:573 grammar LogManager.java:25 import '='=24
2023-08-27 22:12:37:573 grammar LogManager.java:25 import '>='=25
2023-08-27 22:12:37:573 grammar LogManager.java:25 import '<='=26
2023-08-27 22:12:37:573 grammar LogManager.java:25 import '>'=27
2023-08-27 22:12:37:573 grammar LogManager.java:25 import '<'=28
2023-08-27 22:12:37:573 grammar LogManager.java:25 import '*'=29
2023-08-27 22:12:37:573 grammar LogManager.java:25 import '/'=30
2023-08-27 22:12:37:573 grammar LogManager.java:25 import '+'=31
2023-08-27 22:12:37:573 grammar LogManager.java:25 import '-'=32
2023-08-27 22:12:37:573 grammar LogManager.java:25 import '('=33
2023-08-27 22:12:37:573 grammar LogManager.java:25 import ')'=34
2023-08-27 22:12:37:573 grammar LogManager.java:25 import '{'=35
2023-08-27 22:12:37:573 grammar LogManager.java:25 import '}'=36
2023-08-27 22:12:37:573 grammar LogManager.java:25 import ':'=37
2023-08-27 22:12:37:573 grammar LogManager.java:25 import '['=38
2023-08-27 22:12:37:573 grammar LogManager.java:25 import ']'=39
2023-08-27 22:12:37:573 grammar LogManager.java:25 import ','=40
2023-08-27 22:12:37:573 grammar LogManager.java:25 import '.'=41
2023-08-27 22:12:37:578 grammar LogManager.java:25 tokens={INT=1, FLOAT=2, BOOL=3, STR=4, TRU=5, FAL=6, PRINT=7, IF=8, ELSE=9, WHILE=10, FOR=11, SWITCH=12, CASE=13, IN=14, VAR=15, NUMBER=16, STRING=17, ID=18, DIF=19, IG_IG=20, NOT=21, OR=22, AND=23, IG=24, MAY_IG=25, MEN_IG=26, MAYOR=27, MENOR=28, MUL=29, DIV=30, ADD=31, SUB=32, PARIZQ=33, PARDER=34, LLAVEIZQ=35, LLAVEDER=36, D_PTS=37, CORIZQ=38, CORDER=39, COMA=40, PUNTO=41, WHITESPACE=42, COMMENT=43, LINE_COMMENT=44, 'Int'=1, 'Float'=2, 'Bool'=3, 'String'=4, 'true'=5, 'false'=6, 'print'=7, 'if'=8, 'else'=9, 'while'=10, 'for'=11, 'switch'=12, 'case'=13, 'in'=14, 'var'=15, '!='=19, '=='=20, '!'=21, '||'=22, '&&'=23, '='=24, '>='=25, '<='=26, '>'=27, '<'=28, '*'=29, '/'=30, '+'=31, '-'=32, '('=33, ')'=34, '{'=35, '}'=36, ':'=37, '['=38, ']'=39, ','=40, '.'=41}
2023-08-27 22:12:37:578 semantics LogManager.java:25 tokens={EOF=-1, INT=1, FLOAT=2, BOOL=3, STR=4, TRU=5, FAL=6, PRINT=7, IF=8, ELSE=9, WHILE=10, FOR=11, SWITCH=12, CASE=13, IN=14, VAR=15, NUMBER=16, STRING=17, ID=18, DIF=19, IG_IG=20, NOT=21, OR=22, AND=23, IG=24, MAY_IG=25, MEN_IG=26, MAYOR=27, MENOR=28, MUL=29, DIV=30, ADD=31, SUB=32, PARIZQ=33, PARDER=34, LLAVEIZQ=35, LLAVEDER=36, D_PTS=37, CORIZQ=38, CORDER=39, COMA=40, PUNTO=41, WHITESPACE=42, COMMENT=43, LINE_COMMENT=44}
2023-08-27 22:12:37:578 semantics LogManager.java:25 strings={'Int'=1, 'Float'=2, 'Bool'=3, 'String'=4, 'true'=5, 'false'=6, 'print'=7, 'if'=8, 'else'=9, 'while'=10, 'for'=11, 'switch'=12, 'case'=13, 'in'=14, 'var'=15, '!='=19, '=='=20, '!'=21, '||'=22, '&&'=23, '='=24, '>='=25, '<='=26, '>'=27, '<'=28, '*'=29, '/'=30, '+'=31, '-'=32, '('=33, ')'=34, '{'=35, '}'=36, ':'=37, '['=38, ']'=39, ','=40, '.'=41}
